{"name":"Protected","tagline":"Protect objects against accidental disclosure in Django's debug mode.   ","body":"### Overview\r\n\r\nWouldn't it completely suck to accidentally leak sensitive configuration data like your AWS keys into the wild while running Django in DEBUG mode? \r\n\r\nYes, Django protects your configuration variables from disclosure if\r\nyour variable name happens to match one of their \"magic\" pattersn like\r\n\"API\" or \"SECRET\".  But good engineers don't depend on magic and that\r\nparticular bit of magic does little to protect your secrets once they\r\nmake it from your configuiration variables into the local varaibles in\r\nyour code, which Django also happily shares in debug mode.\r\n\r\nWell, our new *protected* module puts an end to that problem.  \r\n\r\n### Getting started\r\n\r\nTo get started you need to install procted.  It's been uploaded to Pypi to installation is a cinch: \r\n\r\n``` \r\neasy_install protected\r\n```\r\n\r\nNow lets try it out.  Normally when you create a seccret, its easily\r\nreadable like this:\r\n\r\n```\r\n$ python\r\nPython 2.6.5\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information\"\r\n>>> secret = 'secret'\r\n>>> secret\r\nsecret\r\n```\r\n\r\nThat sort of sucks; ProtectedString tries to remedy this situation by\r\nproviding an alternative `__repr__` method for your secret so it isn't\r\ndisclosed.  Lets try it out\r\n\r\n```\r\n>>> from protected import ProtectedString\r\n>>> secret = ProtectedString(\"uber secret\")\r\n>>> secret\r\n>>> <Protected String #139757326589296 ***********>\r\n```\r\n\r\nNow you can get at the contents of this as a normal string if you really want like this:\r\n\r\n```\r\n>>> str(secret)\r\nuber secret\r\n```\r\n\r\nSo, what's happening?  A ProtectedString object is simply a superclass of a string with `__repr__` overridden to prevent its display.   You can still convert it to a normal string to print its value by calling str() on it, which demotes it to a normal string.\r\n\r\nBut there's a little more happening under the hood than that.\r\n\r\n```\r\n>>> secret + \"!\"\r\n<Protected String #139757326589392 ***********>\r\n>>> str(secret + \"!\")\r\n'uber secret!'\r\n```\r\n\r\nProtectedString can survive basic operations against it.   Even this works\r\n\r\n```\r\n>>> very = \"Very %s!\" % secret\r\n>>> very\r\n<Protected String #139757326548616 ***********>\r\n>>> str(very)\r\n'Very uber secret!'\r\n>>> \r\n```\r\n\r\nThere are some limits to ProtectedString's ability to obfuscate itself.   This operation does not protect the string:\r\n\r\n```\r\n>>> \"%s\" % (secret,)\r\nuber secret\r\n```\r\n\r\nThe difference likes in whom `__rmod__` is called against. \r\n\r\n\r\n`\"%s\" % ProtectedString(\"secret\")` calls ProtectedString's `__rmod__` method.   `\"%s%\" % (ProtectedString(\"secret\"),)` doesn't.  \r\n\r\nWhile imperfect, if we use this, it may decrease the surface area from\r\nwhich secrets might leak.\r\n\r\nAnyhow, I encourage you to play with this, apply it to our config\r\nfiles and try to break it.  Please try to break it.  I look forward to\r\nyour feedback - Adam DePrince (@adamdeprince)\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}